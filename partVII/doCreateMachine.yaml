---
  # Create one or more machines on Digital Ocean. Before running this, make sure
  # that a valid token is present in the environment variable bearerToken
  # Set the following variables using the -e switch to ansible-playbook:
  # machineCount - number of machines to bring up or down, default: 1
  # targetState: "present" will bring up machines, "absent" will shut
  #              them down. Default: present
  # The file config.yaml contains some further items that you might want to
  # adapt
  # The hosts will be named myHost0, myHost1, myHost2, .. and so forth. The script
  # will also create an SSH configuration file ~/.ssh/do_config and include this
  # into your main user-specific SSH configuration file so that you can then
  # simply do ssh myHost0
- name: Create machines
  hosts: localhost
  vars:
    targetState: "present"
    machineCount: 1
  vars_files:
  - config.yaml
  tasks:
  # Prepare the API token
  - name: Set API token
    set_fact:
      apiToken: "{{ lookup('env', 'bearerToken') }}"
  - name: print apiToken
    debug:
      var: apiToken
  # First, we get a list of all available SSH keys. Note that the
  # list of keys will be added to the Ansible facts with the
  # key ssh_keys
  - name: Get available SSH keys
    digital_ocean_sshkey_facts:
      oauth_token: "{{ apiToken }}"
  - name: Prepare JSON query string
    set_fact:
      jsonQueryString: "[?name=='{{ keyName }}']"
  - name: Apply query String to extract matching key data
    set_fact:
      keyData: "{{ ansible_facts['ssh_keys']|json_query(jsonQueryString) }}"
  - name: Get keyId
    set_fact:
      keyId: "{{ keyData[0]['id'] }}"
  #  Clean up ~/.ssh/do_config
  - name: Cleanup SSH config file
    shell: "echo > ~/.ssh/do_config"
  # Having the key Id, we can now bring up the machines
  - name: Bring up or stop machines
    digital_ocean_droplet:
      oauth_token: "{{ apiToken }}"
      image: ubuntu-18-04-x64
      region_id: fra1
      size_id: s-1vcpu-1gb
      ssh_keys: [ "{{ keyId }}" ]
      state: "{{ targetState }}"
      unique_name: yes
      name: "myHost{{ item }}"
      wait: yes
      wait_timeout: 240
      tags:
      - "createdByAnsible"
    loop:  "{{ range(0, machineCount|int )|list }}"
    register: machineInfo
  # Now add hosts to inventory. Note that we only do this if the targetState
  # is present, i.e. if we added a host (or did not change anything), otherwise
  # item.data is empty and we fail. Note the usage of loop_control to
  # avoid a long message containing the entire item
  - name: Add IP address to inventory
    add_host:
      name: "{{ item.data.droplet.name }}"
      ansible_ssh_host: "{{ item.data.droplet.networks.v4[0].ip_address }}"
      ansible_ssh_user: root
      ansible_ssh_private_key_file: "{{ privateKeyFile }}"
      groups: droplets
    loop: "{{ machineInfo.results }}"
    loop_control:
      label: "{{ item.item }}"
    when: targetState == 'present'
  # For each host, we also add an entry to .ssh/do_config
  - name: Add host to SSH config file
    shell: |
      cat >> ~/.ssh/do_config <<EOF
      Host "{{item.data.droplet.name}}"
      HostName "{{ item.data.droplet.networks.v4[0].ip_address }}"
      User "{{userName}}"
      IdentityFile "{{ userPrivateKeyFile }}"
      CheckHostIP "no"
      Compression "yes"
      ForwardX11 "yes"
      StrictHostKeyChecking "no"
      EOF
    loop: "{{ machineInfo.results }}"
    loop_control:
      label: "{{ item.item }}"
    when: targetState == 'present'
  # Include our file in user-specific ssh-configuration file
  # on the control machine
  - name: Include DigitalOcean SSH configuration file
    lineinfile:
      create: yes
      state: present
      path: ~/.ssh/config
      line: Include ~/.ssh/do_config
  # And print success message
  - name: Print results
    debug:
      msg: "Added host {{ item.data.droplet.name }} - use ssh -i {{ userPrivateKeyFile }} -X -C chr@{{ item.data.droplet.networks.v4[0].ip_address }} or ssh  {{ item.data.droplet.name }} to connect"
    loop: "{{ machineInfo.results }}"
    loop_control:
      label: "{{ item.item }}"
    when: targetState == 'present'

#
# Our second play. We now start to work with  our newly created instances. We do not
# gather facts initially to avoid problems if the sshd is not yet up, but explicitly
# wait using wait_for_connection
#
- name: Provision machines
  hosts: droplets
  gather_facts: no
  vars_files:
  - config.yaml
  tasks:
  - name: Wait for connection
    wait_for_connection:
      delay: 5
      sleep: 5
  - name: Gather facts
    setup:
  - name: Create user
    user:
      name: "{{userName}}"
      shell: /bin/bash
      state: present
  - name: Create a directory /home/{{userName}}/.ssh
    file:
      path: "/home/{{userName}}/.ssh"
      group: "{{userName}}"
      owner: "{{userName}}"
      mode: 0700
      state: directory
  - name: Distribute ssh key
    copy:
      src: "{{ userPrivateKeyFile }}.pub"
      dest: "/home/{{userName}}/.ssh/authorized_keys"
      mode: 0700
      owner: "{{userName}}"
      group: "{{userName}}"
  - name: Add newly created user to sudoers file
    lineinfile:
      path: /etc/sudoers
      state: present
      line: "{{userName}}    ALL = NOPASSWD: ALL"
  # Enable firewall, but still allow OpenSSH traffic to come in
  - name: Enable firewall
    ufw:
      name: OpenSSH
      rule: allow
      state: enabled
  # We now install a few packages. We use a loop to
  # do this in one task
  - name: Install some packages
    apt:
      state: latest
      name: "{{ item }}"
      update_cache: yes
      force_apt_get: yes
    loop:
    - python3-pip
    - docker.io
    - golang-go
